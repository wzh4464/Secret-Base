---
toc: true
documentclass: "ctexart"
classoption: "UTF8"

zotero-key: PMJDJUAW
zt-attachments:

- "14576"
title: Co-clustering for federated recommender system
citekey: he2024CoclusteringFederatedRecommender

---

# Co-clustering for federated recommender system

[Zotero](zotero://select/library/items/PMJDJUAW) [attachment](<file:///Volumes/Mac_Ext/Zotero/storage/M47RZX4H/He%20et%20al.%20-%202024%20-%20Co-clustering%20for%20federated%20recommender%20system.pdf>)
> [!note] Page 3821
>
> ABSTRACT
>
> ---
> 随着数据隐私和安全性日益受到关注，联邦推荐系统（FRS）提供了一种在提供高质量推荐和保护用户隐私之间取得平衡的解决方案。然而，由于个性化决策模式的存在，FRS中常见的统计异质性可能会带来挑战。为了解决这个问题并最大化联邦推荐系统中协同过滤（CF）的效益，将客户（用户）和物品分组并学习特定群体的模型是一种直观的考虑。现有的方法要么通过用户表示进行客户聚类，但这有泄露隐私的风险；要么采用经典聚类策略处理物品嵌入或梯度，但我们发现这些策略会受到维度灾难的困扰。在本文中，我们深入研究了K-Means方法在客户分组中的低效性，认为其失败原因在于FRS中的高维度和数据稀疏性，并提出了CoFedRec，一种新的联合聚类联邦推荐机制，以解决客户异质性并增强联邦框架内的协同过滤。具体来说，服务器最初从客户提供的物品网络中制定物品成员资格。随后，在每个通信轮次中，客户根据从物品成员资格中选择的特定物品类别进行分组，从而形成一个智能聚合的群体模型。同时，为了全面捕捉物品之间的全局关系，我们在每个客户的本地训练阶段引入了基于服务器生成的物品成员资格的额外监督对比学习项。我们在四个数据集上进行了广泛的实验，验证了所提CoFedRec的有效性。
> ^KTD23XEMaM47RZX4Hp1
> [!note] Page 3822
>
> To address the challenges mentioned above
> ^79YIJ89CaM47RZX4Hp2
> [!note] Page 3822
>
> In each communication round
>
> ---
> 针对联邦推荐系统（FRS）的聚类机制CoFedRec，旨在无需访问客户档案的情况下有效地对客户进行分组。核心见解来自于以下两点：（i）FR中的客户异质性，（ii）协同过滤（CF）的关键理念，即通过收集多个邻域的偏好来预测用户的兴趣。具体来说，我们通过实验结果分析经典聚类策略的固有限制，并引入了联合聚类机制。在每个通信轮次中，全局聚合作为初步步骤进行，以收集全局物品关系，通过K-Means聚类技术对全局物品表示进行处理，生成物品成员资格。服务器算法随后通过计算客户之间关于特定物品类别的相似性得分来实现联合聚类，这使得特定物品类别可以将用户分为两组：相似组和非相似组。在相似组中，用户对该类物品的反应趋于相似。相似组中的所有客户将使用聚合的群体模型更新其物品嵌入网络，而非相似组的客户则保留其本地模型，等待随后的通信轮次。除了群体模型，物品成员资格也将分发给所有客户。受监督对比学习（SCL）理论的启发，一个本地监督对比项被整合到本地训练阶段，确保本地学习的物品表示保留全局物品洞察。
> ^47HFQZB4aM47RZX4Hp2
> [!note] Page 3822
>
> Failure in User Clustering
>
> ---
>
> 1. 维度灾难
> 2. 实验说明
> ^RICZYIKRaM47RZX4Hp2
> [!note] Page 3823
>
> Co-clustering for User Partitioning
>
> ---
>
> ### 3.1 用户划分的协同聚类
>
> 在第2.2节中，我们讨论了用户聚类的重要性及其在联邦推荐场景下带来的挑战。在本节中，为了应对这一挑战，我们提出了一种基于特定项目类别对用户进行分组的方法，通过聚合可能相似用户组内的更新生成组模型。考虑到用户不太可能在所有项目上都有相同的兴趣，而是对特定类型的项目有共同的偏好，因此根据用户对不同项目类别的喜好对其进行分类是很自然的。具体来说，在每一轮通信中，我们专注于一个项目类别，并根据用户对该类别的喜好或厌恶将其分为两个不同的组。
>
> 为了将协同效应整合到学习过程中，聚合在显示出相似偏好的用户组内进行，因为如果用户对特定类别的项目表现出共同的兴趣，他们可能对其他一些项目也有共同的偏好。因此，这种聚合方法有助于知识的传递，同时保护用户隐私。值得注意的是，这种方法不需要辨别特定项目类型的偏好或厌恶。
>
> 在每轮通信中，服务器需要服务一个核心客户端$c \in U$和一个项目类别$k$，特别是找到相对于项目类别$k$的客户端$c$的邻居。为此，服务器首先对所有参与客户端上传的项目网络进行全局聚合，然后生成一个项目成员关系$M$（将在第3.2节详细解释），详细说明哪些项目属于哪些类别。通过指定项目类别$k$，我们可以获取属于类别$k$的所有项目，表示为$M_k = \{i \mid i \in I, M[i] = k \}$。然后我们计算核心客户端与所有其他参与者在其项目网络的选定项目类别上的相似性。这里我们采用余弦相似度：
>
>$$s_u = \sum_{i \in M_k} \frac{V_{c,i} \cdot V_{u,i}}{|V_{c,i}| \cdot |V_{u,i}|}, \quad u \in P$$
>
> 其中$V_{c,i}$和$V_{u,i}$分别表示核心客户端$c$和参与用户$u$在类别$k$下的项目$i$的向量。$s_u$是核心客户端$c$和参与用户$u$在项目类别$k$上的相似度得分。$P$是参与客户端集。通过这个公式，我们可以获得相似度得分列表$S = \{s_1, s_2, \ldots, s_{|P|} \}$。
>
> 在计算所有参与者的余弦相似度得分后，为了识别相似组$D_s$和不相似组$D_{dis}$，我们提出使用相似度得分的第一个肘点来将参与客户端分为$D_s$和$D_{dis}$，本质上是相似度得分进展率发生显著变化的点。为了找到这个分割点，我们首先对相似度得分进行排序，表示为$\{s_1', s_2', \ldots, s_{|P|}'\}$（这里$s_1'$不再对应于用户1的相似度得分，而是具有最高相似度得分的用户），并构建一条连接相似度得分的第一个点和最后一个点的线：
>
>$$L(x) = s_1' + x (s_{|P|}' - s_1')$$
>
> 其中$x$是确定点在直线$L(x)$上位置的标量参数。对于相似度得分中的每个点$s_u$，我们计算其到直线$L(x)$的垂直距离，这是通过将$s_u$投影到$L(x)$上并计算$s_u$与其投影之间的欧几里得距离来实现的。令$\mathbf{h}_u = s_u - s_1'$是从第一个点$s_1'$到点$s_u$的向量。将$\mathbf{h}_u$投影到$L(x)$上的标量投影为：
>
>$$x_u = \frac{\mathbf{h}_u \cdot (s_{|P|}' - s_1')}{|s_{|P|}' - s_1'|^2}$$
>
> 点$s_u$到$L(x)$的垂直距离$d_u$可以计算为：
>
>$$d_u = |\mathbf{h}_u - x_u (s_{|P|}' - s_1')|$$
>
> 具有最大距离$d_e$到直线$L(x)$的点$e$被认为是肘点。这个点本质上划定了在选定项目类别上的核心客户端的最佳邻居，表示为相似组$D_s$，否则为不相似组$D_{dis}$：
>
>$$
> \begin{cases}
> u \in D_s, & \text{if } d_u \geq d_e, \\
> u \in D_{dis}, & \text{if } d_u < d_e,
> \end{cases}
>$$
>
> 一旦分组完成，将在相似组内进行组聚合以传递协作信息：
>
>$$V_s \leftarrow \frac{1}{|D_s|} \sum_{u \in D_s} V_u$$
>
> 相似组中的所有参与者将用组模型$V_s$更新他们的项目嵌入网络。通过这种协同聚类方法，同一组内的用户可能有相似的偏好，从而信息可以更自信地在它们之间共享。不相似组内的客户端将被忽略，以防止在异质数据之间传递低质量的知识。
> ^SIATBHJGaM47RZX4Hp3
